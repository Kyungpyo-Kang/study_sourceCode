메소드
return이 있을 때
	메소드 내에서 모든 기능을 끝내지 못할 때
	사용하는 부분으로 결과를 돌려주어야 할 때
	

return이 없을 때
	메소드 내에서 모든 기능이 끝났을 때


메소드 사용 목적

1. 재사용의 목적, 반복되는 기능들을 쉽게 관리하기 위해서
	따라서 특정성을 부여해서는 안된다!!!
2. 소스코드 간결화
-----------------------------------------------------------------------
클래스(반)
	공통요소가 모여있는 곳	

	1. 주어이다.
		모든 문장 앞에 클래스가 나오고
		문장 맨 앞은 항상 대문자로 적는다(영어).
		따라서 클래스는 주어이다.
		Monkey.eat("바나나")

		원숭이가 바나나를 먹는다
		[주어]	[목적어]  [동사]

	2. 타입이다.
	
	클래스는 추상적인 개념이고 이 클래스 안에는 필드가 존재한다.
	따라서 필드에 접근하기 위해서는 추상적인 개념을 구체화한
	"객체"가 필요하고 영어로는 instance variable이다.
	
	instance는 예, 예시이다.
	추상적인 개념의 한 예시로서 객체가 나오기 때문이다.
	객체는 저장공간이므로 instance variable이다.
	
	추상적인 클래스를 객체로 만드는 작업을 객체화라고 하며,
	instance라고 한다.

	클래스명 객체명;
	따라서 객체는 클래스 타입이다.

클래스 선언

	class 클래스명{
		필드(객체, 메소드)
	}

클래스 사용

	[객체화]
	클래스명 객체 = new 클래스명();
	객체.필드명
	A.b : A안에 b

	필드에는 여러개의 값이 존재하기 때문에 하나의 저장공간(객체)에
	여러개를 담을 수 없다.
	따라서 필드는 다른 곳(Heap)에 할당되고 그 주소값을 저장하는 것이
	바로 객체이다.

생성자
	클래스명()가 생성자이다.
	생성자는 메소드와 똑같은 기능을 가지고 있지만
	리턴이 없기 때문에 메소드라고 부르지 않는다.
	
	클래스 선언시 자동으로 생성자가 만들어 지고
	코드상에는 나타나지 않는다. 이런 생성자를 기본 생성자라고 하며
	만약 직접 생성자를 선언하게 되면 선언한 생성자가
	기본 생성자가 된다.


생성자의 목적
	1. 클래스의 필드를 메모리에 할당해주고 할당된 필드의 주소값을
	   가지고 온다. 이 주소값이 객체에 저장된다.
	   객체가 필드에 접근하기 위해서는 메모리가 필드를 기억해야 하고
	   이 작업을 생성자가 해준다.

	2. 초기화의 목적

this
	클래스 필드에서 하나의 메소드로 여러 객체를 다루어야 한다.
	만약 메소드 내에서 필드를 사용하고자 할 때 어떤 객체의 필드인지를
	구분할 수가 없다. 따라서 객체에 마침표를 찍어서 필드에 접근하면
	그 객체의 주소가 자동으로 클래스에 넘어가고 그 주소값을
	this에 저장하게 된다.
	그렇기 때문에 this.필드명으로 접근하면 여러 객체도 하나의 메소드에서
	다룰 수 있게 된다.
		
----------------------------------------------------------------------------
Polymorphism(다형성)

	1. 오버로딩(Overloading)
		같은 이름의 메소드를 넘쳐서 불러오는 기법
		매개변수의 갯수 혹은 타입이 다르면
		같은 이름의 메소드로 선언할 수 있다.
	2.
	


















