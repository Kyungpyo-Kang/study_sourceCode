SQL문
	DDL(Data Definition Language) : 데이터 정의어
		테이블에 관련된 쿼리문
	
	-CREAT	: 테이블 생성
	-DROP	: 테이블 삭제
	-ALTER	: 테이블 수정
		1. 테이블명 수정	RENAME TO 새로운 테이블명
		2. 컬럼 추가	ADD(새로운 컬럼명 컬럼타입)
		3. 컬럼명 변경	RENAME COLUMN 생성된 컬럼명 TO 새로운 컬럼명
		4. 컬럼 삭제	DROP COLUMN 생성된 컬럼명
	-TRUNCATE:테이블 내용 전체 삭제

	자료형(TYPE)
	
	숫자	NUMBER(자릿수) : 정수
		NUMBER(자릿수, 소숫점자리수) : 실수

	문자열	CHAR(길이) : 고정형.	
			CHAR(4)에 'A'를 넣으면 A^^^ 빈 자리가 공백으로 채워짐
			형식을 정한 날짜, 주민등록번호처럼 글자수가 절대 변하지 않는 값을 넣는다.
		VARCHAR(길이), VARCHAR2(길이) : 가변형.
			값의 길이만큼 공간이 배정된다. 글자수에 변화가 있는 값을 넣는다.
		
		DATE : FORMAT에 맞춰서 날짜를 저장하는 타입

	DML(Data Manipulation Language) : 데이터 조작어
	-SELECT	: 검색
	-INSERT	: 삽입
	-UPDATE	: 수정
	-DELETE	: 삭제


	DCL
	TCL
--------------------------------------------------------------------------------------------
무결성
	데이터의 정확성, 일관성, 유효성이 유지 되는 것

	정확성
		데이터는 애매하지 않아야 한다.
	일관성
		각 사용자가 일관된 데이터를 볼 수 있도록 해야한다.
	유효성
		데이터가 실제 존재하는 데이터여야 한다.

	
1. 개체 무결성
	모든 테이블이 PK로 선택된 컬럼을 가져야 한다.
	PK로 선택된 컬럼은 고유한 값을 가져야 하며, 빈 값, NULL값은 허용하지 않는다.

2. 참조 무결성
	두 테이블의 데이터가 항상 일관된 값을 갖도록 유지하는 것

3. 도메인 무결성
	컬럼의 타입, NULL값의 허용 등에 대한 사항을 정의하고
	올바른 데이터가 입력 되었는지를 확인하는 것
----------------------------------------------------------------------------------------------
모델링
	추상적인 주제를 DB에 맞게 설계하는 것

1. 요구 분석

2. 개념적 설계(개념 모델링)
	사람->	주문	<-상품
--------------------------------------------------
	ID	주문일	제품번호
	PW	주문번호	제품명
	이름	제품번호	가격
	주소	ID	재고량
	이메일	주소
	생일	

3. 논리적 설계(논리 모델링)
	사람->	주문		<-상품
----------------------------------------------------------
	ID(PK)	주문일		제품번호(PK)
	PW	주문번호(PK)	제품명
	이름	제품번호(FK)	가격
	주소	ID(FK)		재고량
	이메일	주소
	생일	계좌번호(FK)
		↑
		잔고
		계좌번호(PK)
		은행명
		예금주
		CVC


4. 물리적 설계(물리 모델링)

	USER
	ID : VARCHAR(20)
	--------------------
	PW : VARCHAR2(20)
	NAME : VARCHAR2(20)
	ADDRESS : VARCHAR2(30)
	MAIL : VARCHAR2(30)
	BIRTH : DATE
5. 구현


실습)

1. 요구분석
	꽃 테이블과 화분 테이블 2개가 필요하고
	꽃을 구매할 때 화분도 같이 구매한다.
	꽃은 이름과 색깔, 가격이 있고
	화분은 제품번호, 색깔, 모양, 꽃이름이 있다.

2. 개념적 설계(개념 모델링)
3. 논리적 설계(논리 모델링)
4. 물리적 설계(물리 모델링)
5. 구현



















